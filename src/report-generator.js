import fs from 'fs/promises';
import path from 'path';

class ReportGenerator {
  constructor(evaluationConfig) {
    this.config = evaluationConfig;
    this.reportsDir = process.env.REPORTS_DIR || 'reports';
  }

  /**
   * Generate a comprehensive analytical report
   */
  generate(evaluation, extractedContent) {
    const timestamp = new Date().toISOString();
    const reportContent = this.buildAnalyticalReport(evaluation, extractedContent, timestamp);
    
    return {
      content: reportContent,
      filename: `seo-analysis-report.md`,
      metadata: {
        slug: extractedContent.slug,
        timestamp,
        overall_score: evaluation.overall_score,
        url: extractedContent.url
      }
    };
  }

  /**
   * Build detailed analytical report in the requested format
   */
  buildAnalyticalReport(evaluation, content, timestamp) {
    return `# SEO Analysis Report

**Post Title:** ${content.title || 'N/A'}  
**URL:** ${content.url || 'N/A'}  
**Analysis Date:** ${new Date(timestamp).toLocaleDateString()}  
**AI Model:** ${evaluation.model || 'gemini-1.5-flash'}

## Overall Score: ${this.getScoreEmoji(evaluation.overall_score)} ${evaluation.overall_score}/100

${this.generateScoreBar(evaluation.overall_score)}

---

## Score Breakdown

${this.generateScoreTable(evaluation)}

---

## Analysis of Scores

${this.generateDetailedScoreAnalysis(evaluation, content)}

---

## Optimization Recommendation

${this.generateOptimizationRecommendation(evaluation, content)}

---

*Report generated by SEO Blog Checker v1.0.0*`;
  }

  /**
   * Generate detailed analysis for each score component
   */
  generateDetailedScoreAnalysis(evaluation, content) {
    const sections = [];

    // Handle both old and new evaluation formats
    if (evaluation.eeat_score) {
      // New Hostelworld format
      sections.push(this.analyzeEEATScore(evaluation.eeat_score, content));
      sections.push(this.analyzeTechnicalScore(evaluation.technical_score, content));
      sections.push(this.analyzeRelevanceScore(evaluation.relevance_score, content));
      sections.push(this.analyzeTextQualityScore(evaluation.text_quality_score, content));
      sections.push(this.analyzeAIOptimizationScore(evaluation.ai_optimization_score, content));
      sections.push(this.analyzeFreshnessScore(evaluation.freshness_score, content));
    } else if (evaluation.dimensions) {
      // New structured format with dimensions
      Object.entries(evaluation.dimensions).forEach(([key, dimension]) => {
        sections.push(this.analyzeDimension(key, dimension, content));
      });
    }

    return sections.join('\n\n');
  }

  /**
   * Analyze EEAT Score with detailed insights
   */
  analyzeEEATScore(eeatData, content) {
    const score = eeatData.score;
    const analysis = eeatData.analysis || '';
    
    let insights = `**EEAT Score (${score}/100)**: `;
    
    if (score >= 85) {
      insights += `This article demonstrates strong expertise, authoritativeness, and trustworthiness. `;
    } else if (score >= 70) {
      insights += `The article shows good EEAT signals but requires immediate improvement. `;
    } else {
      insights += `EEAT signals are critically weak and must be enhanced immediately. `;
    }

    insights += analysis;

    // Add specific observations based on content
    if (content.images && content.images.length > 0) {
      insights += ` The article includes ${content.images.length} images which enhance trustworthiness and user engagement.`;
    }

    if (content.schema && content.schema.length > 0) {
      insights += ` Schema markup is present (${content.schema.length} types found), which helps search engines understand the content structure.`;
    }

    // Add recommendations with assertive language
    if (eeatData.recommendations && eeatData.recommendations.length > 0) {
      insights += '\n\n**EEAT Actions Required:**\n';
      eeatData.recommendations.forEach((rec, index) => {
        insights += `${index + 1}. ${this.makeAssertive(rec)}\n`;
      });
    }

    return insights;
  }

  /**
   * Analyze Technical Score with detailed insights
   */
  analyzeTechnicalScore(techData, content) {
    const score = techData.score;
    const analysis = techData.analysis || '';
    
    let insights = `**Technical Score (${score}/100)**: `;
    
    if (score >= 90) {
      insights += `The technical structure is excellent. Maintain current standards. `;
    } else if (score >= 75) {
      insights += `The technical foundation is solid but requires immediate fixes in key areas. `;
    } else {
      insights += `Technical SEO is failing and needs comprehensive overhaul immediately. `;
    }

    insights += analysis;

    // Add technical observations with assertive language
    insights += '\n\n**Technical Actions Required:**\n';
    
    if (content.title) {
      const titleLength = content.title.length;
      if (titleLength >= 50 && titleLength <= 60) {
        insights += `â€¢ **Title**: Perfect length (${titleLength} characters) - "${content.title}"\n`;
      } else if (titleLength < 50) {
        insights += `â€¢ **Title**: TOO SHORT (${titleLength} characters) - Expand immediately to 50-60 characters for better SEO impact\n`;
      } else {
        insights += `â€¢ **Title**: TOO LONG (${titleLength} characters) - Shorten immediately to prevent truncation in search results\n`;
      }
    }

    if (content.meta_description) {
      const metaLength = content.meta_description.length;
      if (metaLength >= 150 && metaLength <= 160) {
        insights += `â€¢ **Meta Description**: Optimal length (${metaLength} characters) - Well done\n`;
      } else if (metaLength < 150) {
        insights += `â€¢ **Meta Description**: WASTED OPPORTUNITY (${metaLength} characters) - Expand to 150-160 characters to maximize SERP real estate\n`;
      } else {
        insights += `â€¢ **Meta Description**: WILL BE TRUNCATED (${metaLength} characters) - Shorten immediately\n`;
      }
    }

    if (content.headers && content.headers.length > 0) {
      const h1Count = content.headers.filter(h => h.level === 1).length;
      const h2Count = content.headers.filter(h => h.level === 2).length;
      insights += `â€¢ **Headings**: ${content.headers.length} total headings (${h1Count} H1, ${h2Count} H2)\n`;
      
      if (h1Count === 0) {
        insights += `  ðŸš¨ CRITICAL: Missing H1 tag - Add immediately for proper SEO structure\n`;
      } else if (h1Count > 1) {
        insights += `  ðŸš¨ CRITICAL: Multiple H1 tags detected - Fix immediately, use only one H1\n`;
      } else {
        insights += `  âœ… H1 structure is correct\n`;
      }
    }

    if (content.word_count) {
      if (content.word_count >= 1500) {
        insights += `â€¢ **Content Length**: Excellent depth (${content.word_count} words) - Maintain this standard\n`;
      } else if (content.word_count >= 800) {
        insights += `â€¢ **Content Length**: Adequate (${content.word_count} words) - Expand to 1500+ words for better rankings\n`;
      } else {
        insights += `â€¢ **Content Length**: INSUFFICIENT (${content.word_count} words) - Expand immediately to minimum 800 words\n`;
      }
    }

    // Add recommendations with assertive language
    if (techData.recommendations && techData.recommendations.length > 0) {
      insights += '\n**Technical Fixes Required:**\n';
      techData.recommendations.forEach((rec, index) => {
        insights += `${index + 1}. ${this.makeAssertive(rec)}\n`;
      });
    }

    return insights;
  }

  /**
   * Analyze Relevance Score
   */
  analyzeRelevanceScore(relevanceData, content) {
    const score = relevanceData.score;
    const analysis = relevanceData.analysis || '';
    
    let insights = `**Relevance for User Score (${score}/100)**: `;
    
    if (score >= 85) {
      insights += `The content delivers exceptional value to users. Maintain this standard. `;
    } else if (score >= 70) {
      insights += `Good relevance but must be improved to capture more user intent. `;
    } else {
      insights += `Relevance is failing users - immediate content overhaul required. `;
    }

    insights += analysis;

    // Add content analysis with assertive language
    if (content.content) {
      const sentences = content.content.split(/[.!?]+/).length;
      const avgWordsPerSentence = content.word_count ? Math.round(content.word_count / sentences) : 0;
      
      if (avgWordsPerSentence <= 20) {
        insights += ` The content uses optimal sentence length (avg ${avgWordsPerSentence} words/sentence) for readability.`;
      } else {
        insights += ` Sentences are too long (avg ${avgWordsPerSentence} words/sentence) - Break them down immediately for better readability.`;
      }
    }

    if (relevanceData.recommendations && relevanceData.recommendations.length > 0) {
      insights += '\n\n**Relevance Actions Required:**\n';
      relevanceData.recommendations.forEach((rec, index) => {
        insights += `${index + 1}. ${this.makeAssertive(rec)}\n`;
      });
    }

    return insights;
  }

  /**
   * Analyze Text Quality Score
   */
  analyzeTextQualityScore(textData, content) {
    const score = textData.score;
    const analysis = textData.analysis || '';
    
    let insights = `**Text Quality Score (${score}/100)**: `;
    
    if (score >= 85) {
      insights += `Writing quality is excellent. Maintain these standards. `;
    } else if (score >= 70) {
      insights += `Writing quality is acceptable but must be improved for competitive advantage. `;
    } else {
      insights += `Writing quality is substandard - immediate editorial review required. `;
    }

    insights += analysis;

    // Add readability analysis with assertive language
    if (content.content && content.word_count) {
      const paragraphs = content.content.split('\n\n').filter(p => p.trim().length > 0).length;
      const avgWordsPerParagraph = Math.round(content.word_count / paragraphs);
      
      insights += ` The content has ${paragraphs} paragraphs averaging ${avgWordsPerParagraph} words each.`;
      
      if (avgWordsPerParagraph <= 100) {
        insights += ` This creates excellent readability and scannable content.`;
      } else {
        insights += ` Break down paragraphs immediately - they're too long for optimal readability.`;
      }
    }

    if (textData.recommendations && textData.recommendations.length > 0) {
      insights += '\n\n**Text Quality Fixes Required:**\n';
      textData.recommendations.forEach((rec, index) => {
        insights += `${index + 1}. ${this.makeAssertive(rec)}\n`;
      });
    }

    return insights;
  }

  /**
   * Analyze AI Optimization Score
   */
  analyzeAIOptimizationScore(aiData, content) {
    const score = aiData.score;
    const analysis = aiData.analysis || '';
    
    let insights = `**AI Optimisation Readiness Score (${score}/100)**: `;
    
    if (score >= 80) {
      insights += `Excellent AI and voice search optimization. You're ahead of the competition. `;
    } else if (score >= 60) {
      insights += `AI optimization foundation exists but critical improvements needed immediately. `;
    } else {
      insights += `AI optimization is failing - you're losing traffic to AI-optimized competitors. Fix immediately. `;
    }

    insights += analysis;

    // Analyze structured content with assertive language
    if (content.headers && content.headers.length > 0) {
      const questionHeadings = content.headers.filter(h => 
        h.text.includes('?') || 
        h.text.toLowerCase().startsWith('what') || 
        h.text.toLowerCase().startsWith('how') || 
        h.text.toLowerCase().startsWith('why') || 
        h.text.toLowerCase().startsWith('where')
      ).length;
      
      insights += ` Only ${questionHeadings} out of ${content.headers.length} headings are question-based.`;
      
      if (questionHeadings === 0) {
        insights += ` This is a critical failure - Add question-based headings immediately for voice search optimization.`;
      } else if (questionHeadings < content.headers.length * 0.3) {
        insights += ` Insufficient question-based headings - Convert more headings to questions immediately.`;
      } else {
        insights += ` Good question-based heading ratio - maintain this approach.`;
      }
    }

    if (aiData.recommendations && aiData.recommendations.length > 0) {
      insights += '\n\n**AI Optimization Actions Required:**\n';
      aiData.recommendations.forEach((rec, index) => {
        insights += `${index + 1}. ${this.makeAssertive(rec)}\n`;
      });
    }

    return insights;
  }

  /**
   * Analyze Freshness Score
   */
  analyzeFreshnessScore(freshnessData, content) {
    const score = freshnessData.score;
    const analysis = freshnessData.analysis || '';
    
    let insights = `**Freshness Score (${score}/100)**: `;
    
    if (score >= 80) {
      insights += `Content is current and competitive. Maintain regular updates. `;
    } else if (score >= 60) {
      insights += `Content is aging and losing relevance - update immediately. `;
    } else {
      insights += `Content is outdated and harming your rankings - complete refresh required immediately. `;
    }

    insights += analysis;

    // Add freshness indicators with assertive language
    const currentYear = new Date().getFullYear();
    if (content.content) {
      const hasCurrentYear = content.content.includes(currentYear.toString());
      const hasPreviousYear = content.content.includes((currentYear - 1).toString());
      
      if (hasCurrentYear) {
        insights += ` Content references current year (${currentYear}) - good freshness signal.`;
      } else if (hasPreviousYear) {
        insights += ` Content only references ${currentYear - 1} - Update with ${currentYear} information immediately.`;
      } else {
        insights += ` No recent year references - Add current year (${currentYear}) content immediately.`;
      }
    }

    if (freshnessData.recommendations && freshnessData.recommendations.length > 0) {
      insights += '\n\n**Freshness Actions Required:**\n';
      freshnessData.recommendations.forEach((rec, index) => {
        insights += `${index + 1}. ${this.makeAssertive(rec)}\n`;
      });
    }

    return insights;
  }

  /**
   * Generate optimization recommendations with assertive language
   */
  generateOptimizationRecommendation(evaluation, content) {
    const score = evaluation.overall_score;
    let recommendation = '';

    if (score >= 80) {
      recommendation = `This article performs well with a score above 80, but don't get complacent. Continue optimizing the lowest-scoring areas to maintain competitive advantage and prevent ranking decay.`;
    } else if (score >= 60) {
      recommendation = `This article is underperforming with significant optimization opportunities. Execute the high-priority recommendations immediately to unlock better rankings and traffic.`;
    } else {
      recommendation = `This article is failing SEO standards and losing you traffic. Implement all critical fixes immediately before working on advanced optimizations. Your competitors are outranking you.`;
    }

    // Add specific suggestions with assertive language
    const suggestions = this.generateSpecificSuggestions(evaluation, content);
    if (suggestions.length > 0) {
      recommendation += '\n\n**Critical Fixes - Execute Immediately:**\n' + suggestions.join('\n');
    }

    // Add missing content sections with assertive language
    const missingSections = this.identifyMissingSections(evaluation, content);
    if (missingSections.length > 0) {
      recommendation += '\n\n**Missing Content - Add Immediately:**\n' + missingSections.join('\n');
    }

    // Add title/meta/heading improvements with assertive language
    const titleMetaImprovements = this.generateTitleMetaImprovements(content);
    if (titleMetaImprovements) {
      recommendation += '\n\n**Title/Meta/Heading Fixes - Execute Now:**\n' + titleMetaImprovements;
    }

    return recommendation;
  }

  /**
   * Generate specific suggestions with assertive language
   */
  generateSpecificSuggestions(evaluation, content) {
    const suggestions = [];

    // Check freshness with assertive language
    if (evaluation.freshness_score && evaluation.freshness_score.score < 70) {
      suggestions.push('â€¢ **Freshness**: Execute complete editorial review immediately. Update all statistics, verify every link, add current year references.');
    }

    // Check AI optimization with assertive language
    if (evaluation.ai_optimization_score && evaluation.ai_optimization_score.score < 70) {
      suggestions.push('â€¢ **AI Optimization**: Add structured FAQ section now. Convert headings to question format immediately for voice search capture.');
    }

    // Check EEAT with assertive language
    if (evaluation.eeat_score && evaluation.eeat_score.score < 80) {
      suggestions.push('â€¢ **EEAT**: Add user testimonials, expert quotes, and authoritative citations immediately. Your credibility is at stake.');
    }

    // Check technical with assertive language
    if (evaluation.technical_score && evaluation.technical_score.score < 85) {
      suggestions.push('â€¢ **Technical**: Fix heading structure, implement internal linking strategy, and deploy proper schema markup immediately.');
    }

    return suggestions;
  }

  /**
   * Identify missing content sections with assertive language
   */
  identifyMissingSections(evaluation, content) {
    const missing = [];

    // Check for FAQ section
    if (!content.content || !content.content.toLowerCase().includes('faq')) {
      missing.push('â€¢ Add comprehensive FAQ section immediately - you\'re missing voice search opportunities');
    }

    // Check for conclusion
    if (!content.content || (!content.content.toLowerCase().includes('conclusion') && !content.content.toLowerCase().includes('summary'))) {
      missing.push('â€¢ Add strong conclusion section now - users and search engines expect closure');
    }

    // Check for call-to-action
    if (!content.content || !content.content.toLowerCase().includes('comment')) {
      missing.push('â€¢ Add clear call-to-action immediately - you\'re wasting engagement opportunities');
    }

    return missing;
  }

  /**
   * Generate title/meta improvements with assertive language
   */
  generateTitleMetaImprovements(content) {
    let improvements = '';

    if (content.title) {
      const titleLength = content.title.length;
      if (titleLength < 50) {
        improvements += `â€¢ **Title**: EXPAND NOW - Current ${titleLength} characters wastes SEO potential. Target 50-60 characters immediately.\n`;
      } else if (titleLength > 60) {
        improvements += `â€¢ **Title**: SHORTEN NOW - Current ${titleLength} characters will be truncated. Cut to 50-60 characters immediately.\n`;
      } else {
        improvements += `â€¢ **Title**: Optimal length (${titleLength} characters) - maintain this standard.\n`;
      }
    }

    if (content.meta_description) {
      const metaLength = content.meta_description.length;
      if (metaLength < 150) {
        improvements += `â€¢ **Meta Description**: EXPAND IMMEDIATELY - Current ${metaLength} characters wastes SERP real estate. Target 150-160 characters.\n`;
      } else if (metaLength > 160) {
        improvements += `â€¢ **Meta Description**: TRIM IMMEDIATELY - Current ${metaLength} characters will be truncated. Cut to 150-160 characters.\n`;
      } else {
        improvements += `â€¢ **Meta Description**: Perfect length (${metaLength} characters) - maintain this standard.\n`;
      }
    }

    if (content.headers && content.headers.length > 0) {
      improvements += `â€¢ **Headings**: Convert to question format immediately (e.g., "What is X?" instead of "X") to capture long-tail searches.\n`;
    }

    return improvements;
  }

  /**
   * Generate score bar visualization
   */
  generateScoreBar(score) {
    const filledBars = Math.round(score / 10);
    const emptyBars = 10 - filledBars;
    const bar = 'â–ˆ'.repeat(filledBars) + 'â–‘'.repeat(emptyBars);
    return `<div align="center">\n\n\`${bar}\` ${score}%\n\n</div>`;
  }

  /**
   * Get emoji based on score
   */
  getScoreEmoji(score) {
    if (score >= 80) return 'ðŸŸ¢';
    if (score >= 60) return 'ðŸŸ¡';
    if (score >= 40) return 'ðŸŸ ';
    return 'ðŸ”´';
  }

  /**
   * Generate comprehensive score breakdown table
   */
  generateScoreTable(evaluation) {
    let table = `| Metric | Score | Weight | Weighted Score | Status |\n`;
    table += `|--------|-------|--------|----------------|--------|\n`;

    if (evaluation.eeat_score) {
      // Hostelworld format with individual scores
      const metrics = [
        { key: 'eeat_score', name: 'EEAT Score', weight: 25 },
        { key: 'technical_score', name: 'Technical Score', weight: 20 },
        { key: 'relevance_score', name: 'Relevance Score', weight: 20 },
        { key: 'text_quality_score', name: 'Text Quality Score', weight: 15 },
        { key: 'ai_optimization_score', name: 'AI Optimization Score', weight: 10 },
        { key: 'freshness_score', name: 'Freshness Score', weight: 10 }
      ];

      metrics.forEach(metric => {
        if (evaluation[metric.key]) {
          const score = evaluation[metric.key].score;
          const weightedScore = (score * metric.weight / 100).toFixed(1);
          const status = this.getScoreStatus(score);
          const emoji = this.getScoreEmoji(score);
          
          table += `| ${metric.name} | ${score}/100 | ${metric.weight}% | ${weightedScore} | ${emoji} ${status} |\n`;
        }
      });

      // Add overall score row
      table += `|--------|-------|--------|----------------|--------|\n`;
      table += `| **Overall Score** | **${evaluation.overall_score}/100** | **100%** | **${evaluation.overall_score}** | **${this.getScoreEmoji(evaluation.overall_score)} ${this.getScoreStatus(evaluation.overall_score)}** |\n`;

    } else if (evaluation.dimensions) {
      // New structured format with dimensions
      Object.entries(evaluation.dimensions).forEach(([key, dimension]) => {
        const name = this.formatDimensionName(key);
        const score = dimension.score;
        const weight = dimension.weight;
        const weightedScore = dimension.weighted_score?.toFixed(1) || (score * weight / 100).toFixed(1);
        const status = this.getScoreStatus(score);
        const emoji = this.getScoreEmoji(score);
        
        table += `| ${name} | ${score}/100 | ${weight}% | ${weightedScore} | ${emoji} ${status} |\n`;
      });

      // Add overall score row
      table += `|--------|-------|--------|----------------|--------|\n`;
      table += `| **Overall Score** | **${evaluation.overall_score}/100** | **100%** | **${evaluation.overall_score}** | **${this.getScoreEmoji(evaluation.overall_score)} ${this.getScoreStatus(evaluation.overall_score)}** |\n`;

    } else {
      // Fallback for other formats
      table += `| Overall Score | ${evaluation.overall_score}/100 | 100% | ${evaluation.overall_score} | ${this.getScoreEmoji(evaluation.overall_score)} ${this.getScoreStatus(evaluation.overall_score)} |\n`;
    }

    return table;
  }

  /**
   * Get score status text
   */
  getScoreStatus(score) {
    if (score >= 90) return 'Excellent';
    if (score >= 80) return 'Good';
    if (score >= 60) return 'Fair';
    if (score >= 40) return 'Poor';
    return 'Critical';
  }

  /**
   * Format dimension names for display
   */
  formatDimensionName(key) {
    const names = {
      seo_technical: 'SEO Technical Foundation',
      content_quality: 'Content Quality & Authority',
      brand_alignment: 'Brand Alignment',
      gen_z_appeal: 'Gen Z Appeal & Engagement',
      user_experience: 'User Experience & Readability',
      ai_optimization: 'AI Optimization & Future-Proofing'
    };
    return names[key] || key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
  }

  /**
   * Save report to file
   */
  async save(report, slug) {
    const slugDir = path.join(this.reportsDir, slug);
    await fs.mkdir(slugDir, { recursive: true });
    
    const reportPath = path.join(slugDir, report.filename);
    await fs.writeFile(reportPath, report.content, 'utf8');
    
    return reportPath;
  }

  /**
   * Convert suggestions to assertive language
   */
  makeAssertive(text) {
    // Convert common suggestion phrases to assertive commands
    return text
      .replace(/consider /gi, '')
      .replace(/you might want to /gi, '')
      .replace(/you could /gi, '')
      .replace(/it would be good to /gi, '')
      .replace(/try to /gi, '')
      .replace(/should /gi, 'must ')
      .replace(/could improve /gi, 'improve immediately')
      .replace(/may want to /gi, 'must ')
      .replace(/would benefit from /gi, 'requires immediate')
      .replace(/recommend /gi, 'execute')
      .replace(/suggest /gi, 'implement now:');
  }
}

export default ReportGenerator;
