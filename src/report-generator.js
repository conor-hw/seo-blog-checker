import { promises as fs } from 'fs';
import path from 'path';

class ReportGenerator {
  constructor(evaluationConfig) {
    this.config = evaluationConfig;
    this.reportsDir = process.env.REPORTS_DIR || 'reports';
  }

  /**
   * Generate a comprehensive Markdown report from evaluation results
   * @param {Object} evaluation - Evaluation results from Gemini AI
   * @param {Object} extractedContent - Original extracted content
   * @returns {Object} Report object with content and metadata
   */
  generate(evaluation, extractedContent) {
    const timestamp = new Date().toISOString();
    const reportContent = this.buildReportContent(evaluation, extractedContent, timestamp);
    
    return {
      content: reportContent,
      filename: `${extractedContent.slug}-evaluation-${Date.now()}.md`,
      metadata: {
        slug: extractedContent.slug,
        timestamp,
        overall_score: evaluation.overall_score,
        url: extractedContent.url
      }
    };
  }

  /**
   * Build the main report content for Hostelworld evaluation
   */
  buildReportContent(evaluation, extractedContent, timestamp) {
    // Check if this is a Hostelworld evaluation (has the new structure)
    if (evaluation.eeat_score) {
      return this.buildHostelworldReport(evaluation, extractedContent, timestamp);
    }
    
    // Fall back to generic report structure
    return this.buildGenericReport(evaluation, extractedContent, timestamp);
  }

  /**
   * Build Hostelworld-specific report
   */
  buildHostelworldReport(evaluation, extractedContent, timestamp) {
    const scoreEmoji = this.getScoreEmoji(evaluation.overall_score);
    
    return `# SEO Analysis Report

**Post Title:** ${extractedContent.title || 'N/A'}  
**URL:** ${extractedContent.url || 'N/A'}  
**Analysis Date:** ${new Date(timestamp).toLocaleDateString()}  
**AI Model:** ${evaluation.model || 'gemini-1.5-flash'}

## Overall Score: ${scoreEmoji} ${evaluation.overall_score}/100

<div align="center">

${this.generateScoreBar(evaluation.overall_score)}

</div>

---

## 📊 Executive Summary

${evaluation.summary || 'Analysis completed successfully.'}

### Key Metrics

| Metric | Score | Status |
|--------|-------|--------|
${this.generateHostelworldMetricsTable(evaluation)}

---

## 🔍 Detailed Analysis

${this.generateHostelworldDetailedAnalysis(evaluation)}

---

## 🎯 Priority Recommendations

${evaluation.priority_recommendations ? 
  evaluation.priority_recommendations.map((rec, index) => `### ${index + 1}. ${rec}`).join('\n\n') : 
  'No specific priority recommendations provided.'}

---

*Report generated by SEO Blog Checker v1.0.0*`;
  }

  /**
   * Generate metrics table for Hostelworld evaluation
   */
  generateHostelworldMetricsTable(evaluation) {
    const metrics = [
      { key: 'eeat_score', name: 'EEAT Score' },
      { key: 'technical_score', name: 'Technical Score' },
      { key: 'relevance_score', name: 'Relevance Score' },
      { key: 'text_quality_score', name: 'Text Quality Score' },
      { key: 'ai_optimization_score', name: 'AI Optimization Score' },
      { key: 'freshness_score', name: 'Freshness Score' }
    ];

    return metrics
      .filter(metric => evaluation[metric.key])
      .map(metric => {
        const score = evaluation[metric.key].score;
        const status = this.getScoreStatus(score);
        const emoji = this.getScoreEmoji(score);
        return `| ${metric.name} | ${score}/100 | ${emoji} ${status} |`;
      })
      .join('\n');
  }

  /**
   * Generate detailed analysis for Hostelworld evaluation
   */
  generateHostelworldDetailedAnalysis(evaluation) {
    const sections = [
      { key: 'eeat_score', name: 'EEAT Score' },
      { key: 'technical_score', name: 'Technical Score' },
      { key: 'relevance_score', name: 'Relevance Score' },
      { key: 'text_quality_score', name: 'Text Quality Score' },
      { key: 'ai_optimization_score', name: 'AI Optimization Score' },
      { key: 'freshness_score', name: 'Freshness Score' }
    ];

    return sections
      .filter(section => evaluation[section.key])
      .map(section => {
        const data = evaluation[section.key];
        const scoreEmoji = this.getScoreEmoji(data.score);
        
        let sectionContent = `### ${section.name} ${scoreEmoji} ${data.score}/100\n\n`;
        sectionContent += `${data.analysis}\n\n`;
        
        if (data.recommendations && data.recommendations.length > 0) {
          sectionContent += '**Recommendations:**\n';
          data.recommendations.forEach((rec, index) => {
            sectionContent += `${index + 1}. ${rec}\n`;
          });
          sectionContent += '\n';
        }
        
        sectionContent += '---\n';
        return sectionContent;
      })
      .join('\n');
  }

  /**
   * Build generic report (existing functionality)
   */
  buildGenericReport(evaluation, extractedContent, timestamp) {
    const dimensionNames = {
      seo_technical: 'SEO Technical Foundation',
      content_quality: 'Content Quality & Authority',
      brand_alignment: 'Hostelworld Brand Alignment',
      gen_z_appeal: 'Gen Z Appeal & Engagement',
      user_experience: 'User Experience & Readability',
      ai_optimization: 'AI Optimization & Future-Proofing'
    };

    return `# SEO Evaluation Report: ${extractedContent.title || extractedContent.slug}

**Generated:** ${new Date(timestamp).toLocaleString()}  
**Page URL:** ${extractedContent.url}  
**Overall Score:** ${evaluation.overall_score}/100

---

## 🎯 Executive Summary

${this.generateExecutiveSummary(evaluation)}

---

## 📊 Detailed Analysis by Dimension

${Object.entries(evaluation.dimensions || {}).map(([key, dimension]) => 
  this.generateDimensionSection(key, dimension, dimensionNames[key])
).join('\n\n---\n\n')}

---

## 🚀 Action Plan

### 🔥 Top Priorities (Do First)
${evaluation.summary.top_priorities.map((priority, index) => 
  `${index + 1}. **${priority}**`
).join('\n')}

### ⚡ Quick Wins (Easy Impact)
${evaluation.summary.quick_wins.map((win, index) => 
  `${index + 1}. **${win}**`
).join('\n')}

### 📈 Long-term Strategy
${evaluation.summary.long_term_strategy.map((strategy, index) => 
  `${index + 1}. **${strategy}**`
).join('\n')}

---

## 📋 Implementation Roadmap

### Week 1-2: Immediate Actions
${this.getActionsByTimeline(evaluation, 'Immediate')}

### Month 1: Short-term Improvements
${this.getActionsByTimeline(evaluation, '1-2 weeks')}

### Month 2+: Long-term Enhancements
${this.getActionsByTimeline(evaluation, '1 month+')}

---

## 📈 Expected Impact

${this.generateImpactAnalysis(evaluation)}

---

*Report generated by SEO Blog Checker v1.0.0*`;
  }

  /**
   * Generate report header
   * @param {Object} extractedContent - Original content
   * @param {Object} evaluation - Evaluation results
   * @returns {string} Header section
   */
  generateHeader(extractedContent, evaluation) {
    const scoreColor = this.getScoreColor(evaluation.overall_score);
    const scoreEmoji = this.getScoreEmoji(evaluation.overall_score);
    
    return `# SEO Analysis Report

**Post Title:** ${extractedContent.title || 'N/A'}  
**URL:** ${extractedContent.url || 'N/A'}  
**Analysis Date:** ${new Date().toLocaleDateString()}  
**AI Model:** ${evaluation.model}

## Overall Score: ${scoreEmoji} ${evaluation.overall_score}/100

<div align="center">

${this.generateScoreBar(evaluation.overall_score)}

</div>

---

`;
  }

  /**
   * Generate executive summary
   * @param {Object} evaluation - Evaluation results
   * @returns {string} Executive summary section
   */
  generateExecutiveSummary(evaluation) {
    const score = evaluation.overall_score;
    let performance, recommendations;

    if (score >= 80) {
      performance = "🟢 **Excellent Performance** - This content is performing very well across most SEO dimensions.";
      recommendations = "Focus on fine-tuning and maintaining current quality while exploring advanced optimization opportunities.";
    } else if (score >= 60) {
      performance = "🟡 **Good Performance** - This content has a solid foundation but has room for improvement.";
      recommendations = "Address the medium and high-priority recommendations to boost performance significantly.";
    } else if (score >= 40) {
      performance = "🟠 **Needs Improvement** - This content requires significant optimization to compete effectively.";
      recommendations = "Focus on high-priority technical SEO fixes and content quality improvements first.";
    } else {
      performance = "🔴 **Poor Performance** - This content needs substantial work across multiple dimensions.";
      recommendations = "Start with fundamental SEO technical fixes before moving to content and engagement improvements.";
    }

    return `${performance}

**Key Recommendation:** ${recommendations}

**Strongest Areas:** ${this.getTopPerformingDimensions(evaluation)}  
**Areas for Improvement:** ${this.getLowestPerformingDimensions(evaluation)}`;
  }

  /**
   * Generate detailed analysis section
   * @param {Object} evaluation - Evaluation results
   * @returns {string} Detailed analysis section
   */
  generateDetailedAnalysis(evaluation) {
    let analysis = '## 🔍 Detailed Analysis\n\n';

    for (const [criterionName, criterionData] of Object.entries(evaluation.evaluations || evaluation)) {
      if (criterionName === 'overall_score' || criterionName === 'optimization_recommendation' || criterionName === 'summary' || criterionName === 'priority_recommendations') {
        continue;
      }
      
      const scoreColor = this.getScoreColor(criterionData.score);
      const scoreEmoji = this.getScoreEmoji(criterionData.score);
      
      analysis += `### ${this.formatCriterionName(criterionName)} ${scoreEmoji} ${criterionData.score}/100\n\n`;
      analysis += `${criterionData.analysis}\n\n`;
      
      if (criterionData.recommendations && criterionData.recommendations.length > 0) {
        analysis += '**Recommendations:**\n';
        criterionData.recommendations.forEach((rec, index) => {
          analysis += `${index + 1}. ${rec}\n`;
        });
        analysis += '\n';
      }
      
      analysis += '---\n\n';
    }

    return analysis;
  }

  /**
   * Generate recommendations section
   * @param {Object} evaluation - Evaluation results
   * @returns {string} Recommendations section
   */
  generateRecommendations(evaluation) {
    const recommendations = evaluation.priority_recommendations || evaluation.recommendations;
    
    if (!recommendations || recommendations.length === 0) {
      return '';
    }

    let recSection = '## 🎯 Priority Recommendations\n\n';
    
    recommendations.forEach((rec, index) => {
      recSection += `### ${index + 1}. ${rec}\n\n`;
    });

    recSection += '---\n\n';
    return recSection;
  }

  /**
   * Generate technical details section
   * @param {Object} evaluation - Evaluation results
   * @param {Object} extractedContent - Original content
   * @returns {string} Technical details section
   */
  generateTechnicalDetails(evaluation, extractedContent) {
    return `## 🔧 Technical Details

### Content Statistics
- **Word Count:** ${this.getWordCount(extractedContent.content)}
- **Title Length:** ${extractedContent.title?.length || 0} characters
- **Meta Description Length:** ${extractedContent.meta_description?.length || 0} characters
- **Keywords Count:** ${extractedContent.keywords?.length || 0}

### Evaluation Configuration
\`\`\`yaml
${JSON.stringify(evaluation.config_used, null, 2)}
\`\`\`

### Raw Evaluation Data
\`\`\`json
${JSON.stringify(evaluation, null, 2)}
\`\`\`

---
`;
  }

  /**
   * Generate metrics table for executive summary
   * @param {Object} evaluation - Evaluation results
   * @returns {string} Metrics table
   */
  generateMetricsTable(evaluation) {
    let table = '';
    
    for (const [criterionName, criterionData] of Object.entries(evaluation.evaluations || evaluation)) {
      if (criterionName === 'overall_score' || criterionName === 'optimization_recommendation' || criterionName === 'summary' || criterionName === 'priority_recommendations') {
        continue;
      }
      
      const status = this.getScoreStatus(criterionData.score);
      const emoji = this.getScoreEmoji(criterionData.score);
      
      table += `| ${this.formatCriterionName(criterionName)} | ${criterionData.score}/100 | ${emoji} ${status} |\n`;
    }
    
    return table;
  }

  /**
   * Generate visual score bar
   * @param {number} score - Overall score
   * @returns {string} Score bar
   */
  generateScoreBar(score) {
    const filledBlocks = Math.round(score / 10);
    const emptyBlocks = 10 - filledBlocks;
    const filled = '█'.repeat(filledBlocks);
    const empty = '░'.repeat(emptyBlocks);
    
    return `\`${filled}${empty}\` ${score}%`;
  }

  /**
   * Get score color for formatting
   * @param {number} score - Score value
   * @returns {string} Color indicator
   */
  getScoreColor(score) {
    if (score >= 80) return '🟢';
    if (score >= 60) return '🟡';
    return '🔴';
  }

  /**
   * Get score emoji
   * @param {number} score - Score value
   * @returns {string} Emoji
   */
  getScoreEmoji(score) {
    if (score >= 90) return '🟢';
    if (score >= 80) return '🟢';
    if (score >= 70) return '🟢';
    if (score >= 60) return '🟡';
    return '🔴';
  }

  /**
   * Get score status text
   * @param {number} score - Score value
   * @returns {string} Status text
   */
  getScoreStatus(score) {
    if (score >= 90) return 'Excellent';
    if (score >= 80) return 'Good';
    if (score >= 70) return 'Fair';
    if (score >= 60) return 'Needs Improvement';
    return 'Poor';
  }

  /**
   * Format criterion name for display
   * @param {string} criterionName - Raw criterion name
   * @returns {string} Formatted name
   */
  formatCriterionName(criterionName) {
    return criterionName
      .split('_')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');
  }

  /**
   * Get word count from text
   * @param {string} text - Text content
   * @returns {number} Word count
   */
  getWordCount(text) {
    if (!text) return 0;
    return text.trim().split(/\s+/).length;
  }

  /**
   * Save report to file
   * @param {Object} report - Report object
   * @param {string} slug - Post slug for filename
   * @returns {Promise<string>} Path to saved report
   */
  async save(report, slug) {
    try {
      // Create reports directory if it doesn't exist
      await fs.mkdir(this.reportsDir, { recursive: true });
      
      // Create post-specific directory
      const postDir = path.join(this.reportsDir, slug);
      await fs.mkdir(postDir, { recursive: true });
      
      // Save main report
      const reportPath = path.join(postDir, 'seo-analysis-report.md');
      await fs.writeFile(reportPath, report.content, 'utf8');
      
      // Save metadata
      const metadataPath = path.join(postDir, 'metadata.json');
      await fs.writeFile(metadataPath, JSON.stringify(report.metadata, null, 2), 'utf8');
      
      // Save raw evaluation data
      const rawDataPath = path.join(postDir, 'raw-evaluation.json');
      await fs.writeFile(rawDataPath, JSON.stringify(report.metadata, null, 2), 'utf8');
      
      return reportPath;
    } catch (error) {
      throw new Error(`Failed to save report: ${error.message}`);
    }
  }

  /**
   * Generate different report formats
   * @param {Object} evaluation - Evaluation results
   * @param {Object} extractedContent - Original content
   * @param {string} format - Report format ('technical', 'executive', 'content-creator')
   * @returns {string} Formatted report
   */
  generateFormattedReport(evaluation, extractedContent, format = 'technical') {
    switch (format) {
      case 'executive':
        return this.generateExecutiveReport(evaluation, extractedContent);
      case 'content-creator':
        return this.generateContentCreatorReport(evaluation, extractedContent);
      default:
        return this.buildReportContent(evaluation, extractedContent);
    }
  }

  /**
   * Generate executive summary report
   * @param {Object} evaluation - Evaluation results
   * @param {Object} extractedContent - Original content
   * @returns {string} Executive report
   */
  generateExecutiveReport(evaluation, extractedContent) {
    return `# SEO Performance Summary

**Post:** ${extractedContent.title}  
**Score:** ${evaluation.overall_score}/100  
**Date:** ${new Date().toLocaleDateString()}

## Key Findings

${evaluation.summary}

## Priority Actions

${evaluation.recommendations.map((rec, index) => `${index + 1}. ${rec}`).join('\n')}

## Performance Overview

${this.generateMetricsTable(evaluation)}
`;
  }

  /**
   * Generate content creator report
   * @param {Object} evaluation - Evaluation results
   * @param {Object} extractedContent - Original content
   * @returns {string} Content creator report
   */
  generateContentCreatorReport(evaluation, extractedContent) {
    return `# Content Optimization Guide

**Post:** ${extractedContent.title}  
**Current Score:** ${evaluation.overall_score}/100

## What's Working Well

${this.getPositiveFeedback(evaluation)}

## Areas for Improvement

${this.getActionableFeedback(evaluation)}

## Quick Wins

${evaluation.recommendations.slice(0, 3).map((rec, index) => `${index + 1}. ${rec}`).join('\n')}

## Next Steps

1. Review the detailed analysis below
2. Implement the top 3 recommendations
3. Re-run analysis after changes
`;
  }

  /**
   * Extract positive feedback from evaluation
   * @param {Object} evaluation - Evaluation results
   * @returns {string} Positive feedback
   */
  getPositiveFeedback(evaluation) {
    const positives = [];
    
    for (const [criterionName, criterionData] of Object.entries(evaluation.evaluations)) {
      if (criterionData.score >= 80) {
        positives.push(`- **${this.formatCriterionName(criterionName)}**: ${criterionData.analysis.split('.')[0]}.`);
      }
    }
    
    return positives.length > 0 ? positives.join('\n') : '- No specific strengths identified in this analysis.';
  }

  /**
   * Extract actionable feedback from evaluation
   * @param {Object} evaluation - Evaluation results
   * @returns {string} Actionable feedback
   */
  getActionableFeedback(evaluation) {
    const improvements = [];
    
    for (const [criterionName, criterionData] of Object.entries(evaluation.evaluations)) {
      if (criterionData.score < 80 && criterionData.recommendations) {
        improvements.push(`- **${this.formatCriterionName(criterionName)}**: ${criterionData.recommendations[0]}`);
      }
    }
    
    return improvements.length > 0 ? improvements.join('\n') : '- No specific improvements needed.';
  }

  generateDimensionSection(key, dimension, name) {
    const scoreEmoji = dimension.score >= 80 ? '🟢' : dimension.score >= 60 ? '🟡' : dimension.score >= 40 ? '🟠' : '🔴';
    
    return `## ${scoreEmoji} ${name}
**Score:** ${dimension.score}/100 (Weight: ${dimension.weight}%, Weighted Score: ${dimension.weighted_score.toFixed(1)})

### Current Analysis
${dimension.analysis}

### Issues Identified
${dimension.issues_found.map(issue => `- ❌ ${issue}`).join('\n')}

### 🛠️ Actionable Recommendations

${dimension.actionable_recommendations.map((rec, index) => 
  this.formatRecommendation(rec, index + 1)
).join('\n\n')}`;
  }

  formatRecommendation(rec, index) {
    const priorityEmoji = rec.priority === 'High' ? '🔴' : rec.priority === 'Medium' ? '🟡' : '🟢';
    const effortEmoji = rec.effort === 'High' ? '🔴' : rec.effort === 'Medium' ? '🟡' : '🟢';
    
    return `#### ${index}. ${priorityEmoji} ${rec.action}

**Priority:** ${rec.priority} | **Effort:** ${effortEmoji} ${rec.effort} | **Timeline:** ${rec.timeline}

**Expected Impact:** ${rec.impact}`;
  }

  getActionsByTimeline(evaluation, timeline) {
    const actions = [];
    Object.values(evaluation.dimensions).forEach(dimension => {
      dimension.actionable_recommendations
        .filter(rec => rec.timeline === timeline)
        .forEach(rec => {
          const priorityEmoji = rec.priority === 'High' ? '🔴' : rec.priority === 'Medium' ? '🟡' : '🟢';
          actions.push(`- ${priorityEmoji} **${rec.action}** (${rec.effort} effort)`);
        });
    });
    
    return actions.length > 0 ? actions.join('\n') : '- No specific actions identified for this timeframe';
  }

  generateImpactAnalysis(evaluation) {
    const totalPossibleImprovement = Object.values(evaluation.dimensions)
      .reduce((sum, dim) => sum + ((100 - dim.score) * (dim.weight / 100)), 0);
    
    return `If all high-priority recommendations are implemented, this page could potentially improve by **${totalPossibleImprovement.toFixed(1)} points**, bringing the overall score to approximately **${(evaluation.overall_score + totalPossibleImprovement).toFixed(1)}/100**.

**Estimated Timeline for Full Implementation:** 2-3 months  
**Resource Requirements:** Content team, technical SEO specialist, design support`;
  }

  getTopPerformingDimensions(evaluation) {
    return Object.entries(evaluation.dimensions)
      .sort((a, b) => b[1].score - a[1].score)
      .slice(0, 2)
      .map(([key, dim]) => `${key.replace('_', ' ')} (${dim.score}/100)`)
      .join(', ');
  }

  getLowestPerformingDimensions(evaluation) {
    return Object.entries(evaluation.dimensions)
      .sort((a, b) => a[1].score - b[1].score)
      .slice(0, 2)
      .map(([key, dim]) => `${key.replace('_', ' ')} (${dim.score}/100)`)
      .join(', ');
  }
}

export default ReportGenerator;
